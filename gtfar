#!/bin/bash



source /export/uec-gs1/knowles/analysis/tade/gtfar_source/optparse
export PATH=$PATH:/export/uec-gs1/knowles/analysis/tade/gtfar_source

#source /export/uec-gs1/knowles/analysis/jen_mapping/gtfar/gtfar_source/optparse
#export PATH=$PATH:/export/uec-gs1/knowles/analysis/jen_mapping/gtfar/gtfar_source


HG19=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/hg19

#HGREF=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/hg19/chr20.fa 
HGREF=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/hg19/hg19.txt

#DATA=/export/uec-gs1/knowles/analysis/tade/gtfar_runs/data

GTF=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/gencode16/gencode.v16.annotation.gtf
DATA=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/gencode16/annotation_data
KEY=$DATA/gc16.key

INDEXES=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/indexes
GC16_IDXS=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/indexes/gc16
HG19_IDXS=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/indexes/hg19

#  INDEXES #

EXON_100_F1=$GC16_IDXS/50_F1_gc16_exonSeqs.index
EXON_100_F2=$GC16_IDXS/50_F2_gc16_exonSeqs.index
EXON_100_F3=$GC16_IDXS/50_F3_gc16_exonSeqs.index
EXON_100_F4=$GC16_IDXS/50_F4_gc16_exonSeqs.index

INTRON_100_F1=$GC16_IDXS/50_F1_gc16_intronSeqs.index
INTRON_100_F2=$GC16_IDXS/50_F2_gc16_intronSeqs.index
INTRON_100_F3=$GC16_IDXS/50_F3_gc16_intronSeqs.index
INTRON_100_F4=$GC16_IDXS/50_F4_gc16_intronSeqs.index

CATCLIP_40_F1=$GC16_IDXS/40_F1_gc16_catsOnly.index
GENECLIP_40_F1=$GC16_IDXS/40_F1_gc16_geneSeqs.index

HG19_100_F1=$HG19_IDXS/50_F1_hg19.index
HG19_100_F2=$HG19_IDXS/50_F2_hg19.index
HG19_100_F3=$HG19_IDXS/50_F3_hg19.index
HG19_100_F4=$HG19_IDXS/50_F4_hg19.index

HG19CLIP_40_F1=$HG19_IDXS/40_F1_hg19.index

KEY=$DATA/gc16.key
CATS=$DATA/gc16_catsOnly.fa
EXONS=$DATA/gc16_exonSeqs.fa
GENES=$DATA/gc16_geneSeqs.fa
INTRONS=$DATA/gc16_intronSeqs.fa
#GTF=$DATA/TEST19_20.gtf 


###  PROGRAMS:  annotate_references.py  call_mutations_from_locations.py  filter_fastq.py  modules  old  optparse  parse_sam_mapping.py



add_arg program 'annotation/filter-reads/iter-map' 

add_option prefix -p 'test' 'OutPut Prefix'
add_option reads -r 'reads.fq/fastq'   'read file in fq format'
add_option output -o 'output'   'output directory'
add_flag showcommands -h 1 'Print all executed commands to standard out' 


parseargs $@




READ_EXT=$(echo $READS | awk -F\. '{print $NF}')

if [ $READ_EXT != "fq" ] && [ $READ_EXT != "fastq" ]; then
    echo "A valid read file in fq format is required"
    echo "EXAMPLE: ./gtfar.sh iter-map -r myreads.fastq -o myoutputdir -r myprefix"
    exit 
fi

if [ -d $OUTPUT ]; then echo "WARNING: output directory ("$OUTPUT") already exists; Files may be overwritten"; 
else mkdir $OUTPUT; fi 






######################################################  MAPPING/PARSING   #################################################################################


function exonic_map_and_parse {

    ITER=$1; MYREADS=$2; MYREF=$3

    if [ $ITER -eq 1 ]; then
        echo  "Mapping reads to exonic seqs (iteration 1)..." 
        perm $EXON_100_F1 $MYREADS --seed F1 -v 2 -B -o exonic1.mapping -u exonic1_miss.fastq --printNM >> MAP.log
        if [ $? != 0 ]; then echo "perm-fail"; exit; fi  
        parse_alignment.py exonic1.mapping -k $KEY --ref=exonic --verbose -p exonic1 --strand - 
        if [ $? != 0 ]; then echo "parse-fail"; exit; fi 
        call_mutations.py exonic1_gene.srt $GTF -g $HG19 -p exonic1 --ref=exonic --annotate --verbose
        if [ $? != 0 ]; then echo "call-fail"; exit; fi 
    elif [ $ITER -eq 2 ]; then
        echo  "Mapping reads to exonic seqs (iteration 2)..." 
        perm exonic1_exonSeqs.fa $MYREADS --seed F3 -v 5 -B -o exonic2.mapping -u exonic2_miss.fastq --printNM >> MAP.log
        if [ $? != 0 ]; then echo "perm-fail"; exit; fi  
        parse_alignment.py exonic2.mapping -k $KEY --ref=exonic -p exonic2 --verbose --strand -
        if [ $? != 0 ]; then echo "parse-fail"; exit; fi  
        sort -m -k14n,14 -k6,6 -k8n,8 exonic1_gene.srt exonic2_gene.srt > exonic_iter_gene.srt
         call_mutations.py exonic_iter_gene.srt $GTF --ref=exonic -g $HG19 -p exonic_iterative --annotate --verbose
        if [ $? != 0 ]; then echo "call-fail"; exit; fi 
    fi
}


function intronic_map_and_parse {

    ITER=$1; MYREADS=$2; MYREF=$3
    if [ $ITER -eq 1 ]; then
        echo  "Mapping reads to intronic seqs (iteration 1)..." 
        perm $INTRON_100_F1 $MYREADS --seed F1 -v 2 -B -o intronic1.mapping -u intronic1_miss.fastq --printNM >> MAP.log
        if [ $? != 0 ]; then echo "perm-fail"; exit; fi  
        parse_alignment.py intronic1.mapping -k $KEY --ref=intronic -p intronic1 --verbose --strand -
        if [ $? != 0 ]; then echo "parse-fail"; exit; fi 
        call_mutations.py intronic1_gene.srt $GTF --ref=intronic -g $HG19 -p intronic1 --annotate --verbose
        if [ $? != 0 ]; then echo "call-fail"; exit; fi 
    elif [ $ITER -eq 2 ]; then
        echo  "Mapping reads to intronic seqs (iteration 2)..." 
        perm intronic1_intronSeqs.fa $MYREADS --seed F3 -v 5 -B -o intronic2.mapping -u intronic2_miss.fastq --printNM >> MAP.log
        if [ $? != 0 ]; then echo "perm-fail"; exit; fi  
        parse_alignment.py intronic2.mapping -k $KEY --ref=intronic -p intronic2 --verbose --strand -
        if [ $? != 0 ]; then echo "parse-fail"; exit; fi 
        sort -m -k14n,14 -k6,6 -k8n,8 intronic1_gene.srt intronic2_gene.srt > intronic_iter_gene.srt
        call_mutations.py intronic_iter_gene.srt $GTF --ref=intronic -g $HG19 -p intronic_iterative --annotate --verbose
        if [ $? != 0 ]; then echo "call-fail"; exit; fi 
    fi
}

function genome_map_and_parse {

    MYREADS=$1 
    echo "Mapping reads to human genome......"
    perm $HG19_100_F2 $MYREADS --seed F2 -v 4 -B -o hg.mapping --printNM -u hg_miss.fastq >> MAP.log 
    perm $HG19_100_F2 $MYREADS --seed F2 -v 4 -B -o hg.sam > /dev/null
    if [ $? != 0 ]; then echo "perm-fail"; exit; fi  
    parse_alignment.py hg.mapping -k $KEY --ref=genomic -p hg --verbose  
    }


function multiple_gapped_alignment {

    MYREADS=$1
    
    echo -n "Performed Gapped Mapping to exons/genes/genome......"
    clipR $CATCLIP_40_F1 $MYREADS --anchorL 40 --seed F1 -v 1 --ignoreRepeatR 10 --ignoreDummyR 45 -u catclip_miss.fastq -o cat_gap.sam --noSamHeader >> MAP.log 
    echo -n "......"
    clipR $GENECLIP_40_F1 catclip_miss.fastq --anchorL 40 --seed F1 -v 1 --ignoreRepeatR 10 --ignoreDummyR 45 -u geneclip_miss.fastq -o gene_gap.sam --noSamHeader >> MAP.log 
    echo -n "......"
    clipR $HG19CLIP_40_F1 geneclip_miss.fastq --anchorL 40 --seed F1 -v 4 --ignoreRepeatR 10 --ignoreDummyR 40 -u remaining_reads.fq -o hg_gap_vis.sam --noSamHeader >> MAP.log 
    if [ $? != 0 ]; then echo "clipR-fail"; exit; else echo "Complete"; fi 

    ## PARSING ##

    parse_alignment.py cat_gap.sam  -k $KEY --ref=exonic  -p cat_gap  --gapped  --verbose 
    parse_alignment.py gene_gap.sam -k $KEY --ref=genes   -p gene_gap --gapped  --verbose 
    parse_alignment.py hg_gap_vis.sam   -k $KEY --ref=genomic -p hg_gap   --gapped  --verbose 

}






if [ $PROGRAM == 'test' ]; then 
   
    echo "GTFAR-Pipeline Verson 0.0.03"
    echo "GtfFile: "$GTF
    echo "Reads:   "$READS
    echo "Output:  "$OUTPUT    
    echo ""

    ## MAPPING TO MAJOR ANNOTATIONS ##

    exonic_map_and_parse 1 $READS   
    intronic_map_and_parse 1 exonic1_miss.fastq 
    exonic_map_and_parse 2 intronic1_miss.fastq
    intronic_map_and_parse 2 exonic2_miss.fastq 

    ### MAPPING TO HG 19 ###
    
    genome_map_and_parse intronic2_miss.fastq
   
    ### GAPPED MAPPING ### 

    multiple_gapped_alignment hg_miss.fastq

    echo "MAPPING-COMPLETE"

    parse_log.py MAP.log

    if [ ! -d tmp ]; then mkdir tmp; fi
    mv *.* tmp/

    echo ""; echo 'Analyzing Results/Creating Bam File'

    cat tmp/*gene.cnts | sort -k1,1 -k5,5 | awk '{if ($5!=L) {if (NR!=1) print A,B,C,"|",L,X,Y,Z; A=$1;B=$2;C=$3;L=$5;X=$6;Y=$7;Z=$8} else {X+=$6;Y+=$7;Z+=$8}} END{print A,B,C,"|",L,X,Y,Z}' > $PREFIX.gene.cnts
    cat tmp/*_iterative.mutations > $PREFIX.mutations
    cat tmp/intronic*_feat.cnts | sort -k1,1 | awk '{if ($1==L) C+=$3; else {if (NR>1) print L,T,C; L=$1;T=$2;C=$3}} END{print L,T,C}' > $PREFIX.intronCnts
    cat tmp/intronic*splice.cnts | sort -k1,1 | awk '{if ($1==L) C+=$3; else {if (NR>1) print L,T,C; L=$1;T=$2;C=$3}} END{print L,T,C}' > $PREFIX.intEx.jxns &
    cat tmp/exonic*splice.cnts | sort -k1,1 | awk '{if ($1==L) C+=$3; else {if (NR>1) print L,T,C; L=$1;T=$2;C=$3}} END{print L,T,C}' > $PREFIX.canonical.splices
    cat tmp/*gap_splice.cnts | sort -k1,1 > $PREFIX.non-canonical.splices
    mv tmp/*novelAreas.cnts > $PREFIX.novelAreas.cnts

    cat tmp/hg.sam tmp/*_vis.sam > $PREFIX.sam
    samtools view -bS -o $PREFIX.bam $PREFIX.sam 
    samtools sort $PREFIX.bam "$PREFIX"_sort
    samtools index "$PREFIX"_sort.bam 

    if [ $? == 0 ]; then echo "Pipeline Complete Successfully"; exit; fi

    cd ..
    exit
fi








