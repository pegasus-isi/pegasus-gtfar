#!/bin/bash

### HARD CODED PATHS ###
source /export/uec-gs1/knowles/analysis/tade/gtfar_source/optparse
export PATH=$PATH:/export/uec-gs1/knowles/analysis/tade/gtfar_source

GC17=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/gencode17






# ------------------------------------------ UTILITY FUNCTIONS ----------------------------------------------------------- #

function show_help {
    echo $1
    echo "Example: gtfar2 map -r SAMPLE_READS.fastq"
    exit
}

function load_annotation {
    if [ $ANNOTATION == "gc17" ] || [ $ANNOTATION == "GC17" ]; then
        SPECIES="HUMAN"
        GENOME_CHRS=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/GRCh37_ensemble19/chrs
        GC17_INDEX=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/gencode17/index_files
        HG19_F1_INDEX=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/GRCh37_ensemble19/index_files/GRCh37_50_F1.index
        HG19_F2_INDEX=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/GRCh37_ensemble19/index_files/GRCh37_50_F2.index
        HG19_F3_INDEX=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/GRCh37_ensemble19/index_files/GRCh37_50_F3.index
        HG19_F4_INDEX=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/GRCh37_ensemble19/index_files/GRCh37_50_F4.index
        HG19_CLIP1_INDEX=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/GRCh37_ensemble19/index_files/GRCh37_40_F1.index
        EXON_INDEX_1=$GC17_INDEX/gc17_exonSeqs_50_F1.index
        INTRON_INDEX_1=$GC17_INDEX/gc17_intronSeqs_50_F1.index
        KNOWN_JXN_INDEX_1=$GC17_INDEX/gc17_knownJxns_50_F1.index
        NOVEL_JXN_INDEX_1=$GC17_INDEX/gc17_novelJxns_50_F1.index
        EXON_INDEX_2=$GC17_INDEX/gc17_exonSeqs_50_F2.index
        INTRON_INDEX_2=$GC17_INDEX/gc17_intronSeqs_50_F2.index
        KNOWN_JXN_INDEX_2=$GC17_INDEX/gc17_knownJxns_50_F2.index
        NOVEL_JXN_INDEX_2=$GC17_INDEX/gc17_novelJxns_50_F3.index
        EXON_CLIP1_40_INDEX=$GC17_INDEX/gc17_exonSeqs_40_F1.index
        GENE_CLIP1_40_INDEX=$GC17_INDEX/gc17_geneSeqs_40_F1.index
        EXONS=$GC17/gc17_exonSeqs.fa
        GENES=$GC17/gc17_geneSeqs.fa
        INTRONS=$GC17/gc17_intronSeqs.fa
        KEY=$GC17/gc17.key
        KNOWN_JXNS=$GC17/gc17_knownJxns.fa
        NOVEL_JXNS=$GC17/gc17_novelJxns.fa
        
        #############
       
        GENOME_REF=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/GRCh37_ensemble19/index_files/GRCh37_50_F1.index
        GENOME_CLIP_REF=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/human/GRCh37_ensemble19/index_files/GRCh37_40_F1.index

        EXONS=$GC17_INDEX/gc17_exonSeqs_50_F1.index
        INTRONS=$GC17_INDEX/gc17_intronSeqs_50_F1.index
        KNOWN_JXNS=$GC17_INDEX/gc17_knownJxns_50_F1.index
        NOVEL_JXNS=$GC17_INDEX/gc17_novelJxns_50_F1.index
        GTF=$GC17/gencode.v17.chr_patch_hapl_scaff.annotation.gtf
    elif [ $ANNOTATION == "MONKEY" ] || [ $ANNOTATION == "monkey" ]; then
        SPECIES="MONKEY"
        ANNOPATH=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/monkey/norgren_annotation
        EXONS=$ANNOPATH/norgRhesus_exonSeqs.fa 
        GENES=$ANNOPATH/norgRhesus_geneSeqs.fa 
        INTRONS=$ANNOPATH/norgRhesus_intronSeqs.fa 
        KNOWN_JXNS=$ANNOPATH/norgRhesus_knownJxns.fa 
        NOVEL_JXNS=$ANNOPATH/norgRhesus_novelJxns.fa 
        KEY=$ANNOPATH/norgRhesus.key  
        GTF=$ANNOPATH/norgren_gcFixFormat.gtf
        GENOME=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/monkey/monkey_genome/norg_genome.txt
        GENOME_CLIP_REF=/export/uec-gs1/knowles/analysis/tade/references_and_annotation/monkey/monkey_genome/norg_genome.txt
        GENOME_CHRS=$GENOME/chrs
    else
        show_help "ANNOTATION $ANNOTATION NOT SUPPORTED -choose gc17 or nothing"
    fi
}


function check_output_dir {
    if [ -d $OUTPUT ]; then echo "WARNING: output directory ("$OUTPUT") already exists; Files may be overwritten"; 
    else mkdir $OUTPUT; fi 
}


function load_and_check_reads {
    READS=$(readlink -m $READS)
    READ_EXT=$(echo $READS | awk -F\. '{print $NF}')
    if [ $READ_EXT != "fq" ] && [ $READ_EXT != "fastq" ]; then
        echo "A valid read file in fq format is required"
        show_help 
    fi
}


function start_up_output {
    echo ""   
    echo "GTFAR-Pipeline Verson 0.0.4"
    echo "SPECIES (-s):        "$SPECIES
    echo "GTF ANNOTATION (-g): "$ANNOTATION "( "$(basename $GTF) ")"
    echo "Reads:               "$READS
    echo "Output Directory:    "$OUTPUT    
    echo "Output File Prefix:  "$PREFIX    
    echo ""
}

########################################################################################################################################################

# ------------------------------------------ PIPELINE FUNCTIONS ----------------------------------------------------------- #

function map_and_count {
    MYPREFIX=$1; MYREADS=$2; MYREF=$3; MYTYPE=$4; MYSEED=$5; MYSUBS=$6
    perm $MYREF $MYREADS --seed $MYSEED -v $MYSUBS -B -o $MYPREFIX.mapping -u $MYPREFIX"_miss.fastq" --printNM > $MYPREFIX.log 
    if [ $? != 0 ]; then echo "perm-fail"; exit; fi 
    echo "parse_alignment.py $MYPREFIX.mapping --strandRule different -k $KEY -p $MYPREFIX --verbose | sort -k4,4 > $MYPREFIX"_gene.srt" &"
    parse_alignment.py $MYPREFIX.mapping --strandRule $STRANDRULE -k $KEY -p $MYPREFIX --verbose | sort -k2,2 -k4n,4 > $MYPREFIX"_gene.srt" &
}

function gap_map_and_count {
    MYPREFIX=$1; MYREADS=$2; MYREF=$3; MYTYPE=$4
    clipR $MYREF $MYREADS -o $MYPREFIX.sam --anchorL 40 --seed F1 -v 2 -e --ignoreRepeatR 10 --ignoreDummyR 40 --noSamHeader --printNM -u $MYPREFIX"_miss.fastq" -s > $MYPREFIX.log
    if [ $? != 0 ]; then echo "perm-fail"; exit; fi 
    parse_alignment.py $MYPREFIX.sam  -k $KEY -p $MYPREFIX --verbose | sort -k2,2 -k4n,4  > $MYPREFIX"_novelGENE.jxns" & 
} 

function hg_map_and_count {
    MYPREFIX=$1; MYREADS=$2; MYREF=$3; MYTYPE=$4; MYSEED=$5; MYSUBS=$6
    perm $MYREF $MYREADS --seed $MYSEED -v $MYSUBS -B -o $MYPREFIX.sam -u $MYPREFIX"_miss.fastq" --printNM  > $MYPREFIX.log
    if [ $? != 0 ]; then echo "perm-fail"; exit; fi 
    echo "parse_alignment.py $MYPREFIX.mapping -k $KEY -p $MYPREFIX --verbose | sort -k4,4 > $MYPREFIX".novel" &"
    parse_alignment.py $MYPREFIX.sam  -k $KEY -p $MYPREFIX --verbose | sort -k2,2 -k4n,4 > $MYPREFIX"_novelGENE.cont" &
}


### ADD SOME OPTIONS FOR MISMATCHES AND WHAT NOT SO YOU CAN DO MORE SELECTION CRITERIA ##

add_arg program 'annotation/filter-reads/iter-map' 
add_option prefix -p 'test' 'OutPut Prefix'
add_option annotation -a 'gc17' 'annotation - currently supported gc17'  
add_option reads -r 'reads.fq/fastq'   'read file in fq format'
add_option strandRule -s 'None'   'A rule for stranded ness (None, Same or Opposite' 
add_option output -o 'output'   'output directory'
add_flag showcommands -h 1 'Print all executed commands to standard out' 

parseargs $@

if [ $PROGRAM == 'map' ]; then 
    
    load_and_check_reads
    check_output_dir
    load_annotation
    start_up_output
    cd $OUTPUT 
    
    map_and_count exons1 $READS $EXONS exonic F1 2 
    map_and_count known_jxns1 exons1_miss.fastq $KNOWN_JXNS exonic F1 2
    map_and_count novel_jxns1 known_jxns1_miss.fastq $NOVEL_JXNS exonic F1 2
    map_and_count introns1 novel_jxns1_miss.fastq $INTRONS intronic F1 2
    wait    
    cat *.srt | sort -k2,2 -k4n,4 > TRANSCRIPTOME.sort 
    #sort -m -k4,4 *.srt > TRANSCRIPTOME.sort 
    call_mutations.py TRANSCRIPTOME.sort -s $SPECIES -p $PREFIX | sort -k2n,2 >  $PREFIX"_transcriptome1.mutations"

    annotate_gtf.py $GTF -g $GENOME_CHRS -p new_ref -m $PREFIX"_transcriptome1.mutations"  -r 100
    KEY=new_ref.key 

    map_and_count exons2 introns1_miss.fastq new_ref_exonSeqs.fa exonic F2 4
    map_and_count known_jxns2 exons2_miss.fastq  new_ref_knownJxns.fa exonic F2 4 
    map_and_count novel_jxns2 known_jxns2_miss.fastq new_ref_novelJxns.fa exonic F2 4    
    map_and_count introns2 novel_jxns2_miss.fastq new_ref_intronSeqs.fa intronic F2 4   
    #wait
    #cat *.srt | sort -k2,2 -k4n,4 > TRANSCRIPTOME_2.sort 
    #call_mutations.py TRANSCRIPTOME_2.sort -s $SPECIES -p $PREFIX | sort -k2n,2 > $PREFIX"_transcriptome2.mutations" 
   
    gap_map_and_count clip_exons1 introns2_miss.fastq new_ref_exonSeqs.fa exonic
    gap_map_and_count clip_gene1 clip_exons1_miss.fastq new_ref_geneSeqs.fa exonic
    
    
    hg_map_and_count hg1 clip_gene1_miss.fastq $GENOME_REF     intergenic F1 2 
    gap_map_and_count hg_gap1 hg1_miss.fastq   $GENOME_CLIP_REF  intergenic 

    

#    sort -m -k2,2 -k4n,4 *.novel > novel.candidates

#    novel_search.py novel.candidates -k $KEY > $PREFIX".novelOutput"

    
    
    
    cd ..
    
    

    ### MAPPING TO HG 19 ###
    
   
    ### GAPPED MAPPING ### 


    echo "MAPPING-COMPLETE"


    exit

    if [ ! -d tmp ]; then mkdir tmp; fi
    mv *.* tmp/

    echo ""; echo 'Analyzing Results/Creating Bam File'


    cat tmp/hg.sam tmp/*_vis.sam > $PREFIX.sam
    samtools view -bS -o $PREFIX.bam $PREFIX.sam 
    samtools sort $PREFIX.bam "$PREFIX"_sort
    samtools index "$PREFIX"_sort.bam 

    if [ $? == 0 ]; then echo "Pipeline Complete Successfully"; exit; fi

    cd ..
    exit
fi








