#!/bin/bash

# ISI COMMENT #1) WE HARDCODE OUR LOCAL PATH SO WE CAN CALL SCRIPTS IN OUR SRC DIR

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
export PATH=$PATH:$DIR
source $DIR/optparse 
source $DIR/gtfar_util.sh

# ISI COMMENT #2) OUR BASH PARSER (OPTPARSE) ALLOWS US TO DECLARE SOME COMMAND LINE OPTIONS

add_title_version "Gtfar (RNA-seq Analysis Pipeline)" "0.0.5"
add_example "Alignment Step" "map -r myreads.fastq"
add_arg map "Run Alignment" 
add_arg filter "filter reads" 
add_arg easyrun "filter and map" 

add_option length -l  DEFAULT=100 TYPE=NUM INT_MIN=50 INT_MAX=128  INFO='length of reads'
add_option MULTI=True INT_MIN=10 INT_MAX=150 trims INFO='trimmings' DEFAULT=50 
add_option MULTI=True TYPE=File -r reads  DEFAULT="None" INFO='reads or file in fastq or fastq.gz format'
add_option config -c  DEFAULT='None' TYPE=File        INFO='Configuration File for Reference Data'

add_option strandRule -s DEFAULT="UNSTRANDED" STR_OPTS=Unstranded,Same,Opposite  INFO='A rule for strandedness (None, Same or Opposite)'
add_option mismatches -m DEFAULT=3 INT_MIN=0 INT_MAX=8    INFO='The number of mismatches to allow per mapping'
add_option verbose DEFAULT="True" TYPE=bool  
add_option trimUnmapped -y DEFAULT="False" TYPE=bool  
add_option mapFiltered  -z DEFAULT="False" TYPE=bool  
add_option outdir -d DEFAULT='None'   INFO='working directory'
add_option inputdir -i DEFAULT='None'   INFO='working directory'
add_option prefix -p DEFAULT='None'   INFO='prefix'


parseargs $@

TRIMS="50 75"
TRIMSTR=$(echo $TRIMS | awk '{$1=$1}1' OFS=",")
TRIMARRAY=($TRIMS)

##### THE OPTIONS PARSER WILL SUPPLY US WITH THE FOLLOWING VARIABLES ######

# 1) $READS -> ONE OR MORE READ FILES [ FASTQ FORMAT IS REQUIRED ] 
# 2) $LENGTH -> INTEGER READ LENGTH (Minimum 64, Maximum 128) (DEFAULT 100) 
# 3) $STRANDRULE -> None, Same, or Opposite 
# 4) $MISMATCHES -> 1,2,3,4,5,6,7 OR 8 mismatches  

#### STEP 1 - VERIFY INPUT PARAMETERS ####

















#--------------------------------------------------------------------------------------------------------------------------------------#



function option_filter { 
    if [ $READS == "NONE" ]; then 
        printf "READS NEEDED FOR OPTION FILTER"; exit ; fi 
    source $DIR/gtfar_filter_scripts.sh

	printf "GTFAR-MODULE: FILTER\n"
    if [ $(echo $READS | awk '{print NF}') -gt 1 ]; then echo "ERROR: FILTER MODULE USES A SINGLE READ FILE"; exit; fi 
	count_and_split_reads $OUTDIR $READS $PREFIX
}

function option_spliceMap  {

	source $DIR/gtfar_map_scripts.sh
    if [ $CONFIG == "NONE" ]; then gtfar_fail "ERROR: A config file is required for mapping - create one using gtfar annotate"; else source $CONFIG; fi
    READS=mapDir_full/reads*unmapped.fastq
    cd $OUTDIR 
    clip_and_parse_reads clipDir "$READS"
    cd ..

}


function option_iterativeMap {
	source $DIR/gtfar_map_scripts.sh
    MAPFILTERED="True"
    if [ $CONFIG == "NONE" ]; then gtfar_fail "ERROR: A config file is required for mapping - create one using gtfar annotate"; else source $CONFIG; fi
    READS=$OUTDIR/filterDir/reads*_full.fastq; MAPDIR=$OUTDIR/mapDir_full
    cd $OUTDIR 
    map_and_parse_reads mapDir_full "filterDir/reads*_full.fastq" "FULL"; UNMAPPED="mapDir_full/reads*unmapped.fastq"

    for ((A=${#TRIMARRAY[@]}-1;A>=0;A--)); do 
        LENGTH=${TRIMARRAY[$A]}
        if [ $(( $A+1 )) -eq ${#TRIMARRAY[@]} ]; then  
            if [ $TRIMUNMAPPED == "True" ]; then map_and_parse_reads mapDir_trim"$LENGTH" $UNMAPPED "TRIM"$LENGTH; UNMAPPED="mapDir_trim"$LENGTH"/reads*unmapped.fastq"; fi 
            if [ $MAPFILTERED == "True" ]; then map_and_parse_reads mapDir_filter"$LENGTH" "filterDir/reads*_"$LENGTH".fastq" "FILTER"$LENGTH; fi 
        else
            if [ $TRIMUNMAPPED == "True" ]; then map_and_parse_reads mapDir_trim"$LENGTH" $UNMAPPED "TRIM"$LENGTH; UNMAPPED="mapDir_trim"$LENGTH"/reads*unmapped.fastq"; fi  
            if [ $MAPFILTERED  == "True" ]; then map_and_parse_reads mapDir_filter"$LENGTH" "filterDir/reads*_"$LENGTH".fastq" "FILTER"$LENGTH; fi        
        fi
    done   
    cat mapDir_*/*.vis > $PREFIX.sam
            
    if [ $TRIMUNMAPPED == "True" ]; then cat mapDir_trim"$LENGTH"/*unmapped.fastq mapDir_trim*/*unmapped.fastq > $PREFIX.unmapped.fastq
    else                            cat mapDir_full/*unmapped.fastq  > $PREFIX.unmapped.fastq; fi

    cd ..
}
    









#--------------------------------------------------------------------------------------------------------------------------------------#

VOLUME="LOUD"; #VOLUME=SILENT

if [ -z $ARGUMENT ]; then
    echo "An argument is required - choose help"
elif [ $ARGUMENT == "filter" ]; then 
    if [ $PREFIX == "NONE" ]; then gtfar_fail "ERROR: An output prefix is required for filter"; fi
    option_filter



elif [ $ARGUMENT == "map" ] || [ $ARGUMENT == "MAP" ]; then
    if [ $PREFIX == "NONE" ]; then gtfar_fail "ERROR: An output prefix is required for easyrun"; fi
    option_iterativeMap
    
elif [ $ARGUMENT == "splicesearch" ]; then 
    option_spliceMap 

elif [ $ARGUMENT == "easyrun" ]; then

    
    if [ $OUTDIR == "NONE" ]; then gtfar_fail "ERROR: A output dir  is required for easyrun"; else mkdir -p $OUTDIR; fi 
    if [ $PREFIX == "NONE" ]; then gtfar_fail "ERROR: An output prefix is required for easyrun"; fi
    if [ $CONFIG == "NONE" ]; then gtfar_fail "ERROR: A config file is required for mapping portion of easyrun - create one using gtfar annotate"; else source $CONFIG; fi


    option_filter 
    option_iterativeMap
    

fi



