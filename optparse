#!/bin/bash

## THIS IS THE SOURCE FOR THE PYTHON LIKE OPTIONS PARSER ## 

############### ARGUMENT, OPTION, AND FLAG PARSING ######################### 

## ADDING ARGUMENTS ##

# add_arg <arg.name> [arg.example]

## ADDING OPTIONS ##

#add_option <option.name> [option.short] [Default Value] [Description]

## ADDING FLAGS ## 

# add_flag <flag.name> [flag.short] [Default = True or False] [Description] 

## ADDITIONAL OPTIONS ## 

# add_argmax, add_argmin, add_noargs, add_info 

############################################################################

#EXAMPLE: Parse a program to copy a txt file K times.  
#True
# add_arg input file.txt 
# add_option times -k 1 'Number of times to copy file' 
# add_flag verbose -v  True Verbosity

# After the command parseargs $@

# The command line: ./prog foo.bar -k 10 -v 
# The command line: ./prog foo.bar --times 10 -v 

# Would yield: FILE=foo.bar, TIMES=10, VERBOSE=1 


# More Info #

# Flag are either True or False; The input of a flag changes it from its default value 
# Option requires an options to be given 

#Default Types are not restricted

# Description is for the help menu


##############  POSITIONAL ARGUMENTS PARSING ############

# Positional arguments will be returned in a list: Argv.  
# To enforce a maximum number of positional arguments use:
# add_arglim <max_number>


############### ADDITIONAL OPTIONS (HELP MENU ) ################ 

# add_info allows a help string to be printed out at the help prompt
# add_example will also allow and example to be printed out at help prompt. 



#################################################################################3


function add_noargs { 
if [ -z != ARG_MIN ] || [ -z != ARG_MAX ]; then 
	echo 'ParseERROR: No Arg cannot be set after Args added'
	exit 
fi 
ARG_MIN=0;
ARG_MAX=0; 
}

function add_argmax {
ARG_MAX=$1; } 

function add_argmin { 
ARG_MIN=$1;
} 

function add_info {
if [ $# -ge 2 ]; then echo 'ERROR: add_info requires a single input'; exit; fi 
HELP_INFO=$1; }



function cleandir { 
	if test -d $1 ; then 
		rm -r $1 
		fi 
	mkdir  $1
}	


function cleanfile {
	if test -f $1 ; then 
		rm $1
	fi; }




function add_arg { 

if [ $# == 0 ]; then echo 'ERROR: add_arg requires at least one argument'; exit; fi
if [ -z $ARGS_ADDED ]; 
	then 
	ARGS_ADDED=1 
else
	ARGS_ADDED=`expr $ARGS_ADDED + 1` 
fi 
ARG_NAMES[$ARGS_ADDED]=$(echo $1 | tr "[:lower:]" "[:upper:]")

if [ $# -gt 1 ]; then 
	ARG_EX[$ARGS_ADDED]=' '"$2"'' 
else 
	ARG_EX[$ARGS_ADDED]=' '"$1"'' 
fi 
if [ $# -gt 2 ]; then echo 'Error: add_arg requires at most two arguments (name, example)'; exit; fi  
}



function add_flag {
if [ $# == 0 ]; then echo 'ERROR: add_flag requires at least one argument'; exit; fi  
if [ $# == 1 ]; then 
	local SHRT='None' 
	local DEF=0
fi 

if [ -z $FLAGS_ADDED ]; 
	then 
	FLAGS_ADDED=1 
else
	FLAGS_ADDED=`expr $FLAGS_ADDED + 1`
fi 


if [ $# == 2 ]; then
	if [ $2 == 0 ] || [ $2 == 1 ]; then 
		local SHRT='None'
		local DEF=$2
	else
		if [ $(echo '-'"$2" | sed 's/.\(.\).*/\1/g') == '-' ] && [ ${#2} == 2 ]; then
			local SHRT=$(echo '-'"$2" | sed 's/..\(.\).*/\1/g')
			local DEF=0
		else
			echo 'ERROR: Wrong Flag Input '"$2"
			exit 
		fi 
	fi 
fi 
if [ $# -ge 3 ]; then 
	if [ $(echo '-'"$2" | sed 's/.\(.\).*/\1/g') == '-' ]  && [ ${#2} == 2 ]; then
		local SHRT=$(echo '-'"$2" | sed 's/..\(.\).*/\1/g')
	else
		echo 'Error: Incorrect Short Form Input: '"$2"
		exit 
	fi 
	if [ $3 == 1 ] || [ $3 == 0 ] || [ $3 == "True" ] || [ $3 == "False" ]; then 
        if [ $3 == "True" ] || [ $3 == 0 ]; then
            local DEF=0
        else
            local DEF=1
        fi
	else
        echo $3
		echo 'Error: Flag default can only be True or False '"$3"
		exit 
	fi
fi 
FLAG_DEF[$FLAGS_ADDED]=$DEF
FLAG_NAMES[$FLAGS_ADDED]=$(echo $1 | tr "[:lower:]" "[:upper:]")
if [ $SHRT == 'None' ]; then 
	FLAG_SHORT[$FLAGS_ADDED]=
else
	FLAG_SHORT[$FLAGS_ADDED]='-'$SHRT 
fi 
FLAG_LONG[$FLAGS_ADDED]='--'$1 

hput '__'"$(echo $1 | tr "[:lower:]" "[:upper:]")" short $SHRT TYPE Flag DEFAULT $DEF
eval $(echo $1 | tr "[:lower:]" "[:upper:]")=$DEF

if [ $# == 4 ]; then FLAG_DES[$FLAGS_ADDED]=$4 
else FLAG_DES[$FLAGS_ADDED]='None'  
fi 
if [ $# -ge 5 ]; then 
echo 'Error: add_flag takes at most 4 paramters'
exit 
fi 
}


	

function add_option { 

## ADDING AN OPTION INVOLVES: option name, [option.short], [Default Value], [Description]
## THe long form will always be the option name.  The Default Value will be None if it is not set.  

if [ $# == 0 ]; then echo 'ERROR: add_option requires at least one argument'; exit; fi 

if [ $1 == 'multi' ] || [ $1 == "MULTI" ]; then
    shift
    local MULTI='True'
else
    local MULTI='False'
fi

if [ $# == 1 ]; then 
	local SHRT='None' 
	local DEF='None' 
fi 
if [ -z $OPTS_ADDED ]; 
	then 
	OPTS_ADDED=1 
else
	OPTS_ADDED=`expr $OPTS_ADDED + 1`
fi 
if [ $# == 2 ]; then
	if [ $(echo '-'"$2" | sed 's/.\(.\).*/\1/g') == '-' ] && [ ${#2} == 2 ]; then
		local DEF='None' 
		local SHRT=$(echo '-'"$2" | sed 's/..\(.\).*/\1/g') 
	else 
		local SHRT='None'
		local DEF=$2 	
	fi 
fi 

if [ $# -ge 3 ]; then 
	if [ $(echo '-'"$2" | sed 's/.\(.\).*/\1/g') == '-' ] && [ ${#2} == 2 ]; then
		local SHRT=$(echo '-'"$2" | sed 's/..\(.\).*/\1/g')
	else
		echo 'Error: Incorrect Short Form Input: '"$2"
		exit 
	fi 
	local DEF=$3
fi 
OPT_DEF[$OPTS_ADDED]=$DEF
OPT_NAMES[$OPTS_ADDED]=$(echo $1 | tr "[:lower:]" "[:upper:]")

if [ $SHRT == 'None' ]; then 
	OPT_SHORT[$OPTS_ADDED]=
else
	OPT_SHORT[$OPTS_ADDED]='-'$SHRT 
fi 
OPT_LONG[$OPTS_ADDED]='--'$1



hput '__'"$(echo $1 | tr "[:lower:]" "[:upper:]")" short $SHRT TYPE Optn DEFAULT $DEF MULTI $MULTI
eval $(echo $1 | tr "[:lower:]" "[:upper:]")=$DEF

if [ $# == 4 ]; then OPT_DES[$OPTS_ADDED]=$4 
else OPT_DES[$OPTS_ADDED]='None'  
fi 
if [ $# -ge 5 ]; then 
echo 'Error: add_option takes at most 4 paramters'
exit 
fi 
}




function usage {

	if [ $ARG_MIN == 0 ] && [ $ARG_MAX == 0 ]; then 
		ARG_RULES=
	fi 

	if [ $ARG_MIN == 0 ] && [ $ARG_MAX == 100 ]; then 
		ARG_RULES=' <Positional Arguments>' 
	fi 

	if [ -z != $ARG_MIN ] && [ -z $ARG_MAX ]; then 
		ARG_RULES=' <'"$ARG_MIN"' or more Positional Argument(s)>' 
	fi 
	if [ -z != $ARG_MAX ] && [ -z $ARG_MIN ]; then 
			ARG_RULES=' <'"$ARG_MAX"' or fewer Positional Argument(s)>'
	fi 
	if [ -z != $ARG_MAX ] && [ -z != ARG_MIN ]; then 
		if [ $ARG_MIN == $ARG_MAX ]; then 
			ARG_RULES=' <'"$ARG_MAX"' Positional Argument(s)>'
		else
			ARG_RULES=' <'"$ARG_MIN"'-'"$ARG_MAX"' Positional Argument(s)>'
		fi 
	fi 
	j=0
	if [ -z != $ARGS_ADDED ]; then 
		ARG_EXAMPLE=$(echo ' '"${ARG_EX[@]}") 
	
	fi 
	if [ -z != $(echo $HELP_INFO | sed 's/\(.\).*/\1/g') ]; then echo $HELP_INFO ; echo '';fi 

	if [ -z != $OPTS_ADDED ] && [ -z != $FLAGS_ADDED ]; then 
		echo 'Usage: '"$0"' '"$ARG_RULES"'  [-options ]  [--flags] ' 
		echo '' 
		echo 'Example: '"$0"''"$ARG_EXAMPLE"'  [-options ]  [--flags] ' 
	fi 
	if [ -z != $OPTS_ADDED ] && [ -z $FLAGS_ADDED ]; then 	   
		echo 'Usage: '"$0"' '"$ARG_RULES"'  [-options ] ' 
		echo '' 
		echo 'Example: '"$0"''"$ARG_EXAMPLE"'  [-options ] ' 
	fi 
	if [ -z $OPTS_ADDED ] && [ -z != $FLAGS_ADDED ]; then 
		echo 'Usage: '"$0"' '"$ARG_RULES"'  [--flags] ' 
		echo '' 
		echo 'Example: '"$0"''"$ARG_EXAMPLE"' [--flags] ' 
	fi 

	if [ -z $OPTS_ADDED ] && [ -z $FLAGS_ADDED ]; then 
		echo 'Usage: '"$0"''"$ARG_RULES"
		echo '' 
		echo 'Example: '"$0"''"$ARG_EXAMPLE"' '  
	fi 

	if [ -z != $OPTS_ADDED ]; then 
		echo '' 
		echo 'Options (Require Input):' 
		echo '' 
		printf "%12s " 'NAME'
		printf "%8s " 'SHORT'
		printf "%18s " 'LONG'
		printf "%12s " 'Default'
		printf "%30s " 'Description' 
		echo '' 
		until [ $j -gt $OPTS_ADDED ]
			do 
			printf "%12s " ${OPT_NAMES[$j]}
			printf "%8s " ${OPT_SHORT[$j]}
			printf "%18s " ${OPT_LONG[$j]}
			printf "%12s " ${OPT_DEF[$j]}
			echo -n '            ' 
			printf "%s " ${OPT_DES[$j]} 
			echo '' 
			j=`expr $j + 1`
			done
	fi 
	j=0 
	if [ -z != $FLAGS_ADDED ]; then 
		echo ''; echo '' 
		echo 'Flags (Boolean):' 
		echo '' 
		printf "%12s " 'NAME'
		printf "%8s " 'SHORT'
		printf "%18s " 'LONG'
		printf "%12s " 'Default'
		printf "%30s " 'Description' 
		echo '' 
		until [ $j -gt $FLAGS_ADDED ]
			do 
			printf "%12s " ${FLAG_NAMES[$j]}
			printf "%8s " ${FLAG_SHORT[$j]}
			printf "%18s " ${FLAG_LONG[$j]}
			printf "%12s " ${FLAG_DEF[$j]}
			echo -n '            ' 
			printf "%s " ${FLAG_DES[$j]} 			
			echo '' 
			j=`expr $j + 1`
			done
	fi 
	exit 
}

hput() {
    eval "$1"='$1...$3...$5...$7'
    eval "$3"='$1'
    eval "$1""$2"='$3' 
    eval "$1""$4"='$5'    
    eval "$1""$6"='$7'
    eval "$1""$8"='$9'    
}

hget() {
    eval echo '${'"$1"'#hash}'		
}





function parseargs {

    ARG_MIN=0; ARG_MAX=100

    if  [ -z $ARG_MIN ] && [ -z $ARGS_ADDED ]; then  ARG_MIN=0; fi
    if  [ -z $ARG_MAX ] && [ -z $ARGS_ADDED ]; then  ARG_MAX=0; fi
	
	if [ -z != $ARGS_ADDED ]; then 
		if [ -z $ARG_MIN ]; then
			ARG_MIN=$ARGS_ADDED
		fi
		if [ -z $ARG_MAX ]; then 
			ARG_MAX=$ARGS_ADDED
		fi 
	
	fi 

	
	Argc=0
	Argv[$Argc]=$0
	if [ $# == 0 ]; then
		if [  $ARG_MIN -gt 0 ]; then  
			echo 'ERROR: No Supplied Arguments' 
			usage 
			exit 
		fi
	fi  
	
	until [ -z "$1" ]  # Until all parameters used up . . .
	do
		if [ $1 == '--help' ] || [ $1 == '-h' ] || [ $1 == 'help' ] || [ $1 == 'HELP' ]; then usage; fi
		if [ $1 == '--manual' ] || [ $1 == 'man' ] || [ $1 == 'manual' ] || [ $1 == 'MAN' ]; then usage; fi


		#if [ -z != $ARG ];
		if [ -z != $CURRENT_OPTION ];
            # IF PREV ITEM WAS OPTION - THEN ARG WILL BE TRUE AND NEXT ITEM WILL BE ADDED #
			then
			VAR=$(echo $CURRENT_OPTION | sed 's/..\(.*\)/\1/g') 
			#echo "UM" $VAR $CURRENT_OPTION
            if [ $(echo $1 | sed 's/\(.\).*/\1/g') == '-' ];
				then 
				echo 'ERROR: An argument is required for this option: '"$VAR" 
				echo ''
				usage 
				exit 
			else
                if [ $(echo `hget "$CURRENT_OPTION""MULTI"`) == "True" ]; then
                    STR=$1
                    shift
			        while [ $(echo '-'"$1" | sed 's/.\(.\).*/\1/g') != '-' ] && [ $# -gt 0 ]                                 
                    do
                        STR=$STR" "$1
                        shift
                    done
                    eval $VAR=\"$STR\"
                else
				    eval $VAR=$1
                    shift
                fi
				CURRENT_OPTION=
                continue 
			fi	
		else
            # IF PREV ITEM WAS NOT AN OPTION -> EVALUATE CURRENT ITEM #
			if [ $(echo '-'"$1" | sed 's/.\(.\).*/\1/g') != '-' ];
                # IF ITEM DOES NOT BEGIN WITH DASH -- IE ITS A POSITIONAL ARGUMENT #
				then
				Argc=`expr $Argc + 1`
				Argv[$Argc]=$1 
			else
                # IF ITEM BEGINS WITH A DASH#
				if [ $(echo '-'"$1" | sed 's/..\(.\).*/\1/g') == '-' ];
                    # IF THERE IS ANOTHER DASH THEN IT IS A LONG FORM ITEM # 
					then 
					CURRENT_OPTION=$(echo $1 | sed 's/--/__/' | tr "[:lower:]" "[:upper:]")
					if [ -z $(echo `hget "$CURRENT_OPTION"`) ]; then
                        ## MAKE SURE THE LONG FORM ITEM IS VALID ##
						echo 'ERROR: The long form option: '"$1"' is undeclared';
						echo '' 
						usage  
						exit 
					fi
				else
                   # THERE IS NOT ANOTHER DASH - IT IS A SHORT FORM ITEM # 
					CURRENT_OPTION=$(echo `hget $(echo '-'"$1" | sed 's/..\(.*\)/\1/g')`)
					if [ -z "$CURRENT_OPTION" ]; then
                        ## MAKE SURE THE LONG FORM ITEM IS VALID ##
						echo 'ERROR: The short form option: '"$1"' is undeclared'
						echo '' 
						usage 
						exit 
					fi  
				fi			
				if [ $(echo `hget "$CURRENT_OPTION""TYPE"`) == Flag ]; then
                    # IF ITEM IS A FLAG THEN TURN THE FLAG ON/OFF AND SET THE ITEM BACK TO NULL # 
					VAR=$(echo $CURRENT_OPTION | sed 's/..\(.*\)/\1/g')
					if [ $(echo `hget "$CURRENT_OPTION""DEFAULT"`) == 1 ]; then eval $VAR=0; fi 
					if [ $(echo `hget "$CURRENT_OPTION""DEFAULT"`) == 0 ]; then eval $VAR=1; fi   
					CURRENT_OPTION= 
				#else
				#	ARG=True
				fi 
			fi
	 	
	shift	
		fi 
	done 
	
	if [ -z != $CURRENT_OPTION ]; then
		VAR=$(echo $CURRENT_OPTION | sed 's/..\(.*\)/\1/g') 
		echo 'ERROR: An argument is required for this option: '"$VAR" 
		usage 
		exit 
	fi 

	if [ -z $ARG_MAX ]; then ARG_MAX=100; fi 
	if [ -z $ARG_MIN ]; then ARG_MIN=0; fi 


	if [ $Argc -gt $ARG_MAX ]; then
		echo 'ERROR:  Too many arguments supplied ('"$Argc"')' 
		usage
		exit 
	fi 
		
	if [ $Argc -lt $ARG_MIN ]; then  
		echo 'ERROR: Two few arguments supplied ('"$Argc"')' 
		usage
		exit 
	fi 
	for((k=1; k<= $Argc; k++)) do 
		if [ $k -gt ${#ARG_NAMES[@]} ]; then break; fi 
		eval ${ARG_NAMES[$k]}=${Argv[$k]}
	done 
}
